class Investor:
    """
    All the data about the investor.
    
    Takes information characteristic for the investor, i.e.: initial funds (unitless measure),
    strategy (greedy, cautious, neutral), luck (50% at standard), risk, profit and creates an instance
    of an investor
    
    Parameters:
    -----------------
    
    strategy: str = "Neutral"
        Defines investing strategy type, characteristic of an investor.
        
        Takes 3 values:
        - Greedy:
            1. Profit-to-Risk ratio (PTRR) drops with respect to gained funds.
            2. Accepts different types of PTRR behaviour: linear, sigmoidal
            3. Profit and Risk are more spread out.
            4. Risk is right skewed (values are negative), the more the higher the Profit.
               The Profit is left skewed.
            
        - Cautious:
            1. PTRR is grows with respect to gained funds
            2. Accepts different types of PTRR behaviour: linear, sigmoidal
            3. Profit and Risk are narrower, the more, the higher the funds.
            4. Risk is left skewed, Profit is right skewed.
            
        - Neutral:
            1. PTRR is independent of the gained funds
            2. Profit and Risk are symmetrically spread around their specific means.
            3. The spread of Profit or Risk are independent.
            
    initial_funds: int = 1000
        Initial sum of money to be invested.
        
    luck: float = 0.5
        A collective paramater dependent on proper investment entry, investment exit. Must be a value
        from range (0,1)
        
    risk: tuple = (mean: float = 0.05, low: float = 0.045, high: float = 0.055)
        Acceptable risk for each investment. Takes a tuple of risk values to produce a beta
        distribution with mean, low and high values.
    
    profit: tuple = (mean: float = 0.1, low: float = 0.09, high: float = 0.11)
        Acceptable profit for each investment. Takes a tuple of profit values to produce a beta
        distribution with mean, low and high values.
    
    single_sum: int = 150
        The value of a single investment.
        
    margin: float = 0.5
        Amount of money from the total funds not to be invested.
   
    Methods:
    -----------------
    
    invest_funds(n: int = 25, rounds: int = 100):
        Takes the value of investments and outputs the return of investment (ROI), final funds
        (amount after n rounds of investment), plot with the median, quartile etc. fields
        for the family of [rounds] investments.
    
    """
    
    
    def __init__(self, name, strategy: str="Neutral", initial_funds: int=1000, luck: float=0.5,
                 risk: tuple=(0.05, 0.045, 0.055), profit: tuple=(0.1, 0.09, 0.11),
                 single_sum: int=150, margin: float=0.5):
        
        self.properties = None
        self.name = name
        self.strategy = strategy
        self.initial_funds = initial_funds
        self.luck = luck
        self.risk = risk
        self.profit = profit
        self.single_sum = single_sum
        self.margin = margin
        
        self.properties = dict([("strategy", self.strategy), ("initial_funds", self.initial_funds),
                                ("luck", self.luck), ("risk", self.risk), ("profit", self.profit),
                                ("single_sum", self.single_sum), ("margin", self.margin)])
    
    # PTRR method for calculating Profit-to_Risk Ratio for arbitrary funds
    
    def PTRR(self, funds: float, gamble_limit: float, model: str = "linear", drop: float = 0.001,
             limit: float = 1.0):
        
        """
        Calculates the Profit-to-risk ratio under specified boundary conditions.
        The default values corrrspond to the "Greedy" strategy, with two models available:
        linear and logistic.

        Parameters:
        -----------

        funds: float
            Value at which the PTRR for the next transaction is to be computed
            
        model: str = "linear" or "logistic"
            Model to calculate future PTRR:
            - linear - use linear function; defaults to drop rate such that PTRR = 1 at gamble_limit
            - logistic - use logistic function; defaults to drop rate such that PTRR = 0.5*initial PTRR at gamble_limit

        gamble_limit: float
            Value at which PTRR equals:
            - 1 - model: "linear"
            - 0.5 intial PTRR - model: "logistic"

        drop: float = 0.001
            Drop rate coeficient for the logistic model.
            For values:
            - 0 < drop < 1 - stretches the curve along the funds axis, the more, the lower the value
            - drop >= 1 - returns a step function with a jump at gamble_limit
            
        limit: float = 1.0
            PTRR value to be reached by the model.
            Range depends on the model:
            - Greedy     0 < limit < PTRR_init
            - Neutral    ignored
            - Cautious   PTRR_init < limit
            
        """

        initial_funds = self.initial_funds
        profit = self.profit[0]
        risk = self.risk[0]
        strategy = self.strategy
        
        # Check for the properess of the input

        PTRR_init = profit/risk
        PTRR = None
        
        if strategy == "Greedy":
            
            # Check for valid input calues
            if limit >= PTRR_init:
                raise Exception("Invalid limit. Expected limit<profit/risk for 'Greedy' strategy.")
                
            else:
                change_coeff = - (PTRR_init - 1) / (gamble_limit - initial_funds)

                if funds <= initial_funds:
                    PTRR = PTRR_init
                else:
                    if model == "linear":

                        formula = PTRR_init + change_coeff*(funds - initial_funds)

                        # Set the limit
                        if formula >= PTRR_init:
                            raise Exception("Not greedy enough. The profit is too high with respect to risk.")

                        elif limit <= formula < PTRR_init:
                            PTRR = formula

                        elif formula < limit:
                            PTRR = limit

                    elif model == "logistic":
                        PTRR_0 = - special.expit(drop * (initial_funds - gamble_limit - initial_funds))
                        PTRR = PTRR_init + (PTRR_init - limit) * (- PTRR_0 - special.expit(drop * (funds - gamble_limit - initial_funds)))


        elif strategy == "Cautious":
            
            # Check for valid input calues
            if limit <= PTRR_init:
                raise Exception("Invalid limit. Expected limit>profit/risk for 'Cautious' strategy.")

            else:
                change_coeff = (PTRR_init - 1) / (gamble_limit - initial_funds)

                if funds <= initial_funds:
                    PTRR = PTRR_init
                else:
                    if model == "linear":

                        formula = PTRR_init + change_coeff*(funds - initial_funds)

                        # Set the limit
                        if formula <= PTRR_init:
                            raise Exception("Not cautious enough. The profit is too small with respect to risk.")

                        elif PTRR_init <= formula < limit:
                            PTRR = formula

                        elif formula >= limit:
                            PTRR = limit

                    elif model == "logistic":
                        PTRR_0 = special.expit(drop * (initial_funds - gamble_limit - initial_funds))
                        PTRR = PTRR_init + limit * (- PTRR_0 + special.expit(drop * (funds - gamble_limit - initial_funds)))


        elif strategy == "Neutral":
            PTRR = PTRR_init
            
        else:
            raise Exception("Invalid strategy. Only 'Greedy', 'Neutral' and 'Cautious' accepted.")
            
        return PTRR
    
class Invest:
    
    """
    Takes the investor and adopts specified conditions (strategy, single_sum) to simulate the funds after n rounds
    of investment.
    """
    
    def __init__(self, investor: Investor = None, strategy: str = "Neutral"):
        
        self.investor = investor
        self.strategy = strategy
    
    
    def Invest_funds(self, single_sum: float=130, strategy: str = "Neutral", n: int = 25):
        
        """
        Returns the funds after n rounds of investment.
        """
        
        
        # Compute parameter 'b' to provide mode = mean
        def var_b(a, xmax, loc, scale):
    
            var_b = 1 + (a - 1) * (scale + loc - xmax) / (xmax - loc)
    
            return var_b
        
        # initialize shape parameters of the distribution
        
        # Profit parameters
        loc_profit = self.investor.profit[1]
        scale_profit = (self.investor.profit[2] - self.investor.profit[1])
        mode_profit = self.investor.profit[0]
        
        # Risk parameters
        loc_risk = self.investor.risk[1]
        scale_risk = (self.investor.risk[2] - self.investor.risk[1])
        mode_risk = self.investor.risk[0]
        
        a = 10
        b_risk = var_b(a, xmax=mode_risk, loc = loc, scale = scale)
        b_profit = var_b(a, xmax=mode_profit, loc = loc, scale = scale)
        
        # Invest according to the adopted strategy
        
        if self.strategy == "Neutral":
            
            
            # Initialize the parameters
            losses_gains = []
            rounds_passed = 0
            initial_invest_funds = self.investor.initial_funds * self.investor.margin
            fund_track = [self.investor.initial_funds]

            def update_funds_track(fund_track, losses_gains):
                for f in losses_gains:
                    fund_track.append(fund_track[-1] + f)
                
                return fund_track
            
            while rounds_passed <= n:

                # Get the number of single investments from invest_funds sum
                
                # if the number of rounds is greater than remaining, then trim
                num_rounds = np.floor((total_invest_funds * self.investor.margin) / single_sum)
                 
                if rounds_passed+num_rounds > n:
                    # trim according to n
                    rem = n - (rounds_passed+num_rounds)
                    num_rounds = rem
                    
                # compute the losses_gains
                profit_distribution = stats.beta.rvs(x, a=a, b=b_risk, loc = loc_profit,
                                                     scale = scale_profit, size = num_rounds)
                risk_distribution = -stats.beta.rvs(x, a=a, b=b_risk, loc = loc_risk,
                                                   scale = scale_risk, size = num_rounds)
                choice = np.random.choice([0, 1], size = num_rounds, p = [1-self.investor.luck, self.investor.luck])

                # pick loss or gain
                for i in range(len(choice)):
                    if choice[i] == 0:
                        new_loss = risk_distribution[i]
                        losses_gains.append(new_loss)

                    elif choice[i] == 1:
                        new_gain = profit_distribution[i]
                        losses_gains.append(new_gain)

                losses_gains = (1 + losses_gains) * single_sum
                
                # Get the funds to invest
                total_invest_funds += sum(losses_gains)
                
                # Update the funds_track
                update_fund_track(fund_track, losses_gains)
